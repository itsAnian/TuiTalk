%!TEX root = ../../main.tex

\chapter{Implementierung}
Für die Kommunikation zwischen den Clients und dem Backend wurde ein einheitliches Protokoll definiert. Dieses beinhaltet Nachrichten, welche von den Clients zum Backend kommen, Nachrichten welche vom Backend zurück an die Clients gehen und Nachrichten, welche in beide Richtungen geschickt werden. Durch dieses Protokoll ist die Erweiterung für andere Nachrichtentypen ohne großen Aufwand möglich.

\begin{lstlisting}[caption=Kommunikationsprotokoll, label=Kommunikationsprotokoll, basicstyle=\ttfamily\scriptsize]
pub enum TalkProtocol {
    // Client -> Server Commands
    JoinRoom { room_id: i32, uuid: Uuid, username: String, unixtime: u64},
    LeaveRoom { room_id: i32, uuid: Uuid, username: String, unixtime: u64},
    ChangeName {uuid: Uuid, username: String, old_username: String, unixtime: u64},
    Fetch { room_id: i32, limit: i64, fetch_before: u64},
    LocalError { message: String },
    LocalInformation { message: String },

    // Server -> Client Events
    UserJoined { uuid: Uuid, username: String, room_id: i32, unixtime: u64 },
    UserLeft { uuid: Uuid, username: String, room_id: i32, unixtime: u64  },
    UsernameChanged {uuid: Uuid, username: String, old_username: String, unixtime: u64},
    History { text: Vec<TalkProtocol> },
    Error { code: String, message: String },


    // Server <-> Client
    PostMessage { message: TalkMessage },
}
\end{lstlisting}

\section{Clients}
Dieses Protokoll befindet sich neben dem Verbindungsaufbau in einer geteilten Bibliothek. Da die \ac{WS} Verbindung für die unterschiedlichen Clients auf unterschiedlichen Bibliotheken beruht mussten diese seperat implementiert werden. Um die Verbindungen trotzdem gesammelt haben wurden diese auch in der geteilten Bibliothek implementiert.

\subsection{Funktionalitäten}
Beide Clients bieten neben den Grundfunktionen wie Senden und Empfangen von Nachrichten, die folgenden Funktionen:

\begin{table}[h!]
\begin{center}
\begin{tabular}{ | l | m{10cm} | }
\hline
\textbf{Funktion} & \textbf{Beschreibung} \\ 
\hline
/help & Zeigt Informationen zu den verfügbaren Befehlen \\ 
\hline
/clear & Löscht den Chatverlauf \\ 
\hline
/name <String> & Setzt den Nutzernamen \\ 
\hline
/room <Integer> & Wechselt den Raum \\ 
\hline
/fetch <Integer> & Holt ausgehend von der ersten Nachricht im Chatverlauf die vorherigen Nachrichten \\ 
\hline
\end{tabular}
\end{center}
\caption{Funktionen der Clients}
\label{tab:clientcommands}
\end{table}

\section{Backend}
\subsection{Umgang mit Publish und Subscribe von Redis}
Alle Nachrichten die von Clients an einer Backendinstanz ankommen werden auf Redis gepublished.
Das ist nötig für die Kommunikation zwischen den Clients die sich auf verschiedenen Backendinstanzen befinden.
Jede Backendinstanz erstellt pro Client einen Thread, um auf den jeweilig ausgewählten Chatraum zu subscriben.
Zudem kommt ein Future Channel welcher auf eine Raumänderung hört, sodass bei einem Raum wechsel der Thread nicht neu erstellt werden muss.
Dadurch kann ein Raumwechsel über einen Future Channel erfolgen. Im Thread wird kontinuierlich überprüft ob eine Änderung des Raumes stattgefunden hat.
Zudem wird nicht nur die Raum ID (=Redischannel) selbst übertragen, sondern auch ein Oneshot Channel, welcher dazu dient zu zu warten bis der Raumwechsel erfolgt ist und daraufhin eine Acknowledge-Nachricht sendet.
Damit neue Nachrichten nur dann gepublished werden, wenn der Raumwechsel abgeschlossen ist.
Zudem werden Nachrichten aus dem alten Channel wie z. B. die eigene automatische Leave-Nachricht nicht mehr erhalten, wenn auf das Acknowledgement gewartet wird.
Die Connection zu Redis selbst ist beim Publish synchron und beim Subscriben asynchron, beide Connections sind Clusterconnections und sind somit mit mehreren Redis-Nodes verbunden.

Jede Backendinstanz verbindet sich mit der Datenbank, um die Nachrichten zu laden und zu speichern.
Falls während des Betriebes die Datenbank heruntergefahren wird, laufen die Instanzen mit eingeschränkter Funktionalität weiter.
Das heißt im konkreten Fall das keine Nachrichten persistiert werden und demnach von der Clientseite diese auch nicht mehr angefordert werden könnnen.
Falls die Datenbank beim intialen Start nicht verfügbar ist starten die Backendinstanzen jedoch nicht.
